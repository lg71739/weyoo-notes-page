import{_ as t,o as e,c as a,f as i}from"./app-19e0b0f0.js";const n={},d=i('<h1 id="rabbitmq简介" tabindex="-1"><a class="header-anchor" href="#rabbitmq简介" aria-hidden="true">#</a> RabbitMQ简介</h1><h2 id="什么是mq" tabindex="-1"><a class="header-anchor" href="#什么是mq" aria-hidden="true">#</a> 什么是MQ</h2><p>MQ(message queue)，从字面意思上看，本质是个队列，FIFO 先入先出，只不过队列中存放的内容是message 而已，还是一种跨进程的通信机制，用于上下游传递消息。在互联网架构中，MQ 是一种非常常见的上下游“逻辑解耦+物理解耦”的消息通信服务。使用了 MQ 之后，消息发送上游只需要依赖 MQ，不用依赖其他服务。</p><h2 id="mq的作用和劣势" tabindex="-1"><a class="header-anchor" href="#mq的作用和劣势" aria-hidden="true">#</a> MQ的作用和劣势</h2><h3 id="流量消峰" tabindex="-1"><a class="header-anchor" href="#流量消峰" aria-hidden="true">#</a> 流量消峰</h3><p>举个例子，如果订单系统最多能处理一万次订单，这个处理能力应付正常时段的下单时绰绰有余，正常时段我们下单一秒后就能返回结果。但是在高峰期，如果有两万次下单操作系统是处理不了的，只能限制订单超过一万后不允许用户下单。使用消息队列做缓冲，我们可以取消这个限制，把一秒内下的订单分散成一段时间来处理，这时有些用户可能在下单十几秒后才能收到下单成功的操作，但是比不能下单的体验要好。</p><h3 id="应用解耦" tabindex="-1"><a class="header-anchor" href="#应用解耦" aria-hidden="true">#</a> 应用解耦</h3><p>以电商应用为例，应用中有订单系统、库存系统、物流系统、支付系统。用户创建订单后，如果耦合调用库存系统、物流系统、支付系统，任何一个子系统出了故障，都会造成下单操作异常。当转变成基于消息队列的方式后，系统间调用的问题会减少很多，比如物流系统因为发生故障，需要几分钟来修复。在这几分钟的时间里，物流系统要处理的内存被缓存在消息队列中，用户的下单操作可以正常完成。当物流系统恢复后，继续处理订单信息即可，中单用户感受不到物流系统的故障，提升系统的可用性。</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2023/06/7_15_55_24_image-20230607154621559.png" alt="image-20230607154621559" tabindex="0" loading="lazy"><figcaption>image-20230607154621559</figcaption></figure><h3 id="异步处理" tabindex="-1"><a class="header-anchor" href="#异步处理" aria-hidden="true">#</a> 异步处理</h3><p>有些服务间调用是异步的，例如 A 调用 B，B 需要花费很长时间执行，但是 A 需要知道 B 什么时候可以执行完，以前一般有两种方式，A 过一段时间去调用 B 的查询 api 查询。或者 A 提供一个 callback api，B 执行完之后调用 api 通知 A 服务。这两种方式都不是很优雅，使用消息总线，可以很方便解决这个问题，A 调用 B 服务后，只需要监听 B 处理完成的消息，当 B 处理完成后，会发送一条消息给 MQ，MQ 会将此消息转发给 A 服务。这样 A 服务既不用循环调用 B 的查询 api，也不用提供 callback api。同样B 服务也不用做这些操作。A 服务还能及时的得到异步处理成功的消息。</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2023/06/7_15_55_40_image-20230607154706789.png" alt="image-20230607154706789" tabindex="0" loading="lazy"><figcaption>image-20230607154706789</figcaption></figure><h3 id="mq的劣势" tabindex="-1"><a class="header-anchor" href="#mq的劣势" aria-hidden="true">#</a> MQ的劣势</h3><ul><li><p>系统可用性降低</p><p>系统引入的外部依赖越多,系统稳定性越低.一旦MQ宕机,就会对业务系统造成影响,如何保证MQ的高可用?</p></li><li><p>系统复杂度提高</p><p>MQ的加入大大增加了系统的复杂度，以前系统间是同步的远程调用，现在是通过MQ进行异步调用。如何保证消息没有被重复消费?怎么处理消息丢失情况?那么保证消息传递的顺序性?</p></li><li><p>系统一致性</p><p>A系统处理完业务,通过MQ给B、C、D三个系统发消息数据,如果B系统、C系统处理成功, D系统处理失败。如何保证消息数据处理的一致性?</p></li></ul><h2 id="主流mq的对比与选择" tabindex="-1"><a class="header-anchor" href="#主流mq的对比与选择" aria-hidden="true">#</a> 主流MQ的对比与选择</h2><h3 id="主流mq的对比" tabindex="-1"><a class="header-anchor" href="#主流mq的对比" aria-hidden="true">#</a> 主流MQ的对比</h3><table><thead><tr><th style="text-align:center;">特性</th><th style="text-align:center;">ActiveMq</th><th style="text-align:center;">RabbitMq</th><th style="text-align:center;">RocketMQ</th><th style="text-align:center;">Kafka</th></tr></thead><tbody><tr><td style="text-align:center;">成熟度</td><td style="text-align:center;">成熟</td><td style="text-align:center;">成熟</td><td style="text-align:center;">比较成熟</td><td style="text-align:center;">成熟的日志领域</td></tr><tr><td style="text-align:center;">时效性</td><td style="text-align:center;">毫秒级</td><td style="text-align:center;">微秒级</td><td style="text-align:center;">毫秒级</td><td style="text-align:center;">毫秒级</td></tr><tr><td style="text-align:center;">社区活跃度</td><td style="text-align:center;">低</td><td style="text-align:center;">高</td><td style="text-align:center;">高</td><td style="text-align:center;">高</td></tr><tr><td style="text-align:center;">单机吞吐量</td><td style="text-align:center;">万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td><td style="text-align:center;">万级，吞吐量比RocketMQ和Kafka要低了一个数量级</td><td style="text-align:center;">10万级，RocketMQ也是可以支撑高吞吐的一种MQ</td><td style="text-align:center;">10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景</td></tr><tr><td style="text-align:center;">topic数量对吞吐量的影响</td><td style="text-align:center;"></td><td style="text-align:center;"></td><td style="text-align:center;">topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic</td><td style="text-align:center;">topic从几十个到几百个的时候，吞吐量会大幅度下降所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源</td></tr><tr><td style="text-align:center;">可用性</td><td style="text-align:center;">高，基于主从架构实现高可用性</td><td style="text-align:center;">高，基于主从架构实现高可用性</td><td style="text-align:center;">非常高，分布式架构</td><td style="text-align:center;">非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用</td></tr><tr><td style="text-align:center;">消息可靠性</td><td style="text-align:center;">有较低的概率丢失数据</td><td style="text-align:center;"></td><td style="text-align:center;">经过参数优化配置，可以做到0丢失</td><td style="text-align:center;">经过参数优化配置，消息可以做到0丢失</td></tr><tr><td style="text-align:center;">功能支持</td><td style="text-align:center;">MQ领域的功能极其完备</td><td style="text-align:center;">基于erlang开发，所以并发能力很强，性能极其好，延时很低</td><td style="text-align:center;">MQ功能较为完善，还是分布式的，扩展性好</td><td style="text-align:center;">功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准</td></tr><tr><td style="text-align:center;">优劣势总结</td><td style="text-align:center;">非常成熟，功能强大，在业内大量的公司以及项目中都有应用偶尔会有较低概率丢失消息而且现在社区以及国内应用都越来越少，官方社区现维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用</td><td style="text-align:center;">rlang语言开发，性能极其好，延时很低；吞吐量到万级，MQ功能比较完备而且开源提供的管理界面非常棒，用起来很好用社区相对比较活跃，几乎每个月都发布几个版本分在国内一些互联网公司近几年用rabbitmq也比较多一些但是问题也是显而易见的，RabbitMQ确实吞吐量会低一些，这是因为他做的实现机制比较重。而且erlang开发，国内有几个公司有实力做erlang源码级别的研究和定制？如果说你没这个实力的话，确实偶尔会有一些问题，你很难去看懂源码，你公司对这个东西的掌控很弱，基本职能依赖于开源社区的快速维护和修复bug。而且rabbitmq集群动态扩展会很麻烦，不过这个我觉得还好。其实主要是erlang语言本身带来的问题。很难读源码，很难定制和掌控。</td><td style="text-align:center;">接口简单易用，而且毕竟在阿里大规模应用过，有阿里品牌保障日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景而且一个很大的优势在于，阿里出品都是java系的，我们可以自己阅读源码，定制自己公司的MQ，可以掌控社区活跃度相对较为一般，不过也还可以，文档相对来说简单一些，然后接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码还有就是阿里出台的技术，你得做好这个技术万一被抛弃，社区黄掉的风险，那如果你们公司有技术实力我觉得用RocketMQ挺好的</td><td style="text-align:center;">kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集</td></tr></tbody></table><div class="hint-container info"><p class="hint-container-title">AMQP</p><p>AMQP，即Advanced Message Queue Protocol(高级消息队列协议)，是一个网络协议，是应用层协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品、不同开发语言的条件限制。2006年，AMQP规范发布，类比HTTP</p></div><h4 id="mq的选择" tabindex="-1"><a class="header-anchor" href="#mq的选择" aria-hidden="true">#</a> MQ的选择</h4><p>1.Kafka</p><p>Kafka 主要特点是基于Pull 的模式来处理消息消费，追求高吞吐量，一开始的目的就是用于日志收集和传输，适合产生大量数据的互联网服务的数据收集业务。大型公司建议可以选用，如果有日志采集功能，肯定是首选 kafka 了。尚硅谷官网 kafka 视频连接</p><p>2.RocketMQ</p><p>天生为金融互联网领域而生，对于可靠性要求很高的场景，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RoketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，如果你的业务有上述并发场景，建议可以选择RocketMQ。</p><p>3.RabbitMQ</p><p>结合 erlang 语言本身的并发优势，性能好时效性微秒级，社区活跃度也比较高，管理界面用起来十分方便，如果你的数据量没有那么大，中小型公司优先选择功能比较完备的 RabbitMQ。</p>',25),r=[d];function l(c,s){return e(),a("div",null,r)}const g=t(n,[["render",l],["__file","10-1686123116171.html.vue"]]);export{g as default};
