import{_ as e,o as a,c as s,f as i}from"./app-19e0b0f0.js";const n={},c=i(`<h1 id="git-后悔药" tabindex="-1"><a class="header-anchor" href="#git-后悔药" aria-hidden="true">#</a> Git 后悔药</h1><h2 id="撤销" tabindex="-1"><a class="header-anchor" href="#撤销" aria-hidden="true">#</a> 撤销</h2><h3 id="工作区-如何撤回修改" tabindex="-1"><a class="header-anchor" href="#工作区-如何撤回修改" aria-hidden="true">#</a> 工作区：如何撤回修改</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout -- <span class="token operator">&lt;</span>file<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>注意</strong>：<code>git checkout -- &lt;file&gt;</code>是一个危险的命令，这很重要。你对那个文件做的任何修改都会消失——你只是拷贝了另一个文件来覆盖它。除非你确实清楚不想要那个文件了，否则不要使用这个命令</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_17_7_202402141017260.png" alt="image-20210927213637033" tabindex="0" loading="lazy"><figcaption>image-20210927213637033</figcaption></figure><h3 id="暂存区-如何撤回暂存" tabindex="-1"><a class="header-anchor" href="#暂存区-如何撤回暂存" aria-hidden="true">#</a> 暂存区：如何撤回暂存</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> reset HEAD <span class="token operator">&lt;</span>file<span class="token operator">&gt;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_17_16_202402141017023.png" alt="image-20210927214503365" tabindex="0" loading="lazy"><figcaption>image-20210927214503365</figcaption></figure><h3 id="版本库-如何撤回提交" tabindex="-1"><a class="header-anchor" href="#版本库-如何撤回提交" aria-hidden="true">#</a> 版本库：如何撤回提交</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> commit <span class="token parameter variable">--amend</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个命令会将暂存区中的文件提交。如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。最终你只会有一个提交——第二次提交将代替第一次提交的结果</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_17_25_202402141017218.png" alt="image-20210927215042057" tabindex="0" loading="lazy"><figcaption>image-20210927215042057</figcaption></figure><h2 id="重置" tabindex="-1"><a class="header-anchor" href="#重置" aria-hidden="true">#</a> 重置</h2><h3 id="第一部-移动-head" tabindex="-1"><a class="header-anchor" href="#第一部-移动-head" aria-hidden="true">#</a> 第一部：移动 HEAD</h3><p><code>reset</code>做的第一件事是移动 HEAD 的指向。假设我们再次修改了 file.txt 文件并第三次提交它</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_17_31_202402141017291.png" alt="image-20210927223918740" tabindex="0" loading="lazy"><figcaption>image-20210927223918740</figcaption></figure><p>现在的历史看起来是这样</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_17_38_202402141017880.png" alt="image-20210927221853468" tabindex="0" loading="lazy"><figcaption>image-20210927221853468</figcaption></figure><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> reset <span class="token parameter variable">--soft</span> HEAD~ 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_17_43_202402141017135.png" alt="image-20210927224927134" tabindex="0" loading="lazy"><figcaption>image-20210927224927134</figcaption></figure><p>这与改变 HEAD 自身不同（<code>checkout</code>所做的）；<code>reset</code>移动 HEAD 指向的分支</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_17_50_202402141017326.png" alt="image-20210927221957520" tabindex="0" loading="lazy"><figcaption>image-20210927221957520</figcaption></figure><p>看一眼上图，理解一下发生的事情：它本质上是撤销了上一次<code>git commit</code>命令。 当你在运行<code>git commit</code>时，Git 会创建一个新的提交，并移动 HEAD 所指向的分支来使其指向该提交。当你将它<code>reset</code>回 HEAD~（HEAD 的父结点）时，其实就是把该分支移动回原来的位置，而不会改变索引和工作目录。现在你可以更新索引并再次运行<code>git commit</code>来完成<code>git commit --amend</code>所要做的事情了</p><h3 id="第二部-更新暂存区" tabindex="-1"><a class="header-anchor" href="#第二部-更新暂存区" aria-hidden="true">#</a> 第二部：更新暂存区</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> reset <span class="token punctuation">[</span>--mixed<span class="token punctuation">]</span> HEAD~
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p><strong>注意</strong>：<code>git reset HEAD~</code>等同于<code>git reset –-mixed HEAD~</code></p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_18_9_202402141018671.png" alt="image-20210927230350880" tabindex="0" loading="lazy"><figcaption>image-20210927230350880</figcaption></figure><p>如下图所示</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_17_56_202402141017846.png" alt="image-20210927225108595" tabindex="0" loading="lazy"><figcaption>image-20210927225108595</figcaption></figure><p>理解一下发生的事情：它依然会撤销上次提交，但还会取消暂存所有的东西。于是，我们回滚到了所有<code>git add</code>和<code>git commit</code>的命令执行之前</p><h3 id="第三部-更新工作区" tabindex="-1"><a class="header-anchor" href="#第三部-更新工作区" aria-hidden="true">#</a> 第三部：更新工作区</h3><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> reset <span class="token parameter variable">--hard</span> HEAD~
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_18_17_202402141018979.png" alt="image-20210927231153847" tabindex="0" loading="lazy"><figcaption>image-20210927231153847</figcaption></figure><p>如下图所示</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_18_25_202402141018396.png" alt="image-20210927230620978" tabindex="0" loading="lazy"><figcaption>image-20210927230620978</figcaption></figure><p>你撤销了最后的提交、<code>git add</code>和<code>git commit</code>命令以及工作目录中的所有工作</p><p><strong>注意</strong>：必须注意，<code>--hard</code>标记是<code>reset</code>命令唯一的危险用法，它也是 Git 会真正地销毁数据的仅有的几个操作之一。其他任何形式的<code>reset</code>调用都可以轻松撤消，但是<code>--hard</code>选项不能，因为它强制覆盖了工作目录中的文件。在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 v3 版本，我们可以通过<code>reflog</code>来找回它。但是若该文件还未提交，Git 仍会覆盖它从而导致无法恢复</p><h2 id="路径-reset" tabindex="-1"><a class="header-anchor" href="#路径-reset" aria-hidden="true">#</a> 路径 reset</h2><p>前面讲述了<code>reset</code>基本形式的行为，不过你还可以给它提供一个作用路径。若指定了一个路径，<mark><code>reset</code>将会跳过第 1 步</mark>，并且将它的作用范围限定为指定的文件或文件集合。这样做自然有它的道理，因为 HEAD 只是一个指针，你无法让它同时指向两个提交中各自的一部分。不过索引和工作目录可以部分更新，所以重置会继续进行第 2、3 步。 现在，假如我们运行<code>git reset file.txt</code> （这其实是<code>git reset --mixed HEAD file.txt</code>的简写形式），它会：</p><ul><li>移动 HEAD 分支的指向（因为是文件，这一步忽略）</li><li>让索引看起来像 HEAD</li></ul><p>所以它本质上只是将 file.txt 从 HEAD 复制到索引中</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_18_35_202402141018066.png" alt="image-20211001105842463" tabindex="0" loading="lazy"><figcaption>image-20211001105842463</figcaption></figure><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_18_42_202402141018363.png" alt="image-20211001105914468" tabindex="0" loading="lazy"><figcaption>image-20211001105914468</figcaption></figure><h2 id="checkout-与-reset-对比-无路径" tabindex="-1"><a class="header-anchor" href="#checkout-与-reset-对比-无路径" aria-hidden="true">#</a> checkout 与 reset 对比（无路径）</h2><p>运行<code>git checkout [branch]</code>与运行<code>git reset --hard [branch]</code>非常相似，它会更新三者使其看起来像 [branch]，不过有两点重要的区别</p><ol><li>首先不同于<code>reset --hard</code>，<code>checkout</code>对工作目录是安全的，它会通过检查来确保不会将已更改的文件弄丢。而<code>reset --hard</code>则会不做检查就全面地替换所有东西</li><li>第二个重要的区别是如何更新 HEAD。 <code>reset</code>会移动 HEAD 分支的指向，而<code>checkout</code>只会移动 HEAD 自身来指向另一个分支</li></ol><p>例如，假设我们有 master 和 develop 分支，它们分别指向不同的提交；我们现在在 develop 上，如果我们运行<code>git reset master</code>，那么 develop 自身现在会和 master 指向同一个提交。而如果我们运行<code>git checkout master</code>的话，develop 不会移动，HEAD 自身会移动。现在 HEAD 将会指向 master</p><p>所以，虽然在这两种情况下我们都移动 HEAD 使其指向了提交 A，但做法是非常不同的。<code>reset</code>会移动 HEAD 分支的指向，而<code>checkout</code>则移动 HEAD 自身</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_18_51_202402141018520.png" alt="image-20210927233218370" tabindex="0" loading="lazy"><figcaption>image-20210927233218370</figcaption></figure><h2 id="checkout-与-reset-对比-有路径" tabindex="-1"><a class="header-anchor" href="#checkout-与-reset-对比-有路径" aria-hidden="true">#</a> checkout 与 reset 对比（有路径）</h2><p><code>git checkout commithash</code>运行<code>checkout</code>的另一种方式就是指定一个文件路径，这会像<code>reset</code>一样不会移动 HEAD。它就像是<code>git reset --hard [branch] file</code>。 这样对工作目录并不安全，它也不会移动 HEAD，将会跳过第 1 步更新暂存区和工作目录。</p><p><code>git checkout --</code>相比于<code>git reset -- hard commitHash</code>跟文件名的形式，第 1、第 2 步都没做</p><h2 id="数据恢复" tabindex="-1"><a class="header-anchor" href="#数据恢复" aria-hidden="true">#</a> 数据恢复</h2><p>在你使用 Git 的时候，你可能会意外丢失一次提交。通常这是因为你强制删除了正在工作的分支，但是最后却发现你还需要这个分支；亦或者硬重置了一个分支，放弃了你想要的提交。如果这些事情已经发生，该如何找回你的提交呢？</p><h3 id="实例" tabindex="-1"><a class="header-anchor" href="#实例" aria-hidden="true">#</a> 实例</h3><p>假设你已经提交了五次</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline
ab1afef80fac8e34258ff41fc1b867c702daa24b    modified repo a bit 
484a59275031909e19aadb7c92262719cfcdf19a    added repo.rb 
1a410efbd13591db07496601ebc7a059dd55cfe9    third commit
cac0cab538b970a37ea1e769cbbde608743bc96d    second commit 
fdf4fc3344e67ab068f836878b6c4951e3b15f3d    first commit
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在，我们将 master 分支硬重置到第三次提交</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> reset <span class="token parameter variable">--hard</span> 1a410efbd13591db07496601ebc7a059dd55cfe9 
HEAD is now at 1a410ef third commit
$ <span class="token function">git</span> log <span class="token parameter variable">--pretty</span><span class="token operator">=</span>oneline 
1a410efbd13591db07496601ebc7a059dd55cfe9  third commit 
cac0cab538b970a37ea1e769cbbde608743bc96d  second commit 
fdf4fc3344e67ab068f836878b6c4951e3b15f3d  first commit 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>现在顶部的两个提交已经丢失了 - 没有分支指向这些提交。你需要找出最后一次提交的 SHA-1 然后增加一个指向它的分支。 窍门就是找到最后一次的提交的 SHA-1 - 但是估计你记不起来了，对吗？</p><p>最方便，也是最常用的方法，是使用一个名叫<code>git reflog</code>的工具。当你正在工作时，Git 会默默地记录每一次你改变 HEAD 时它的值。每一次你提交或改变分支，引用日志都会被更新</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code>$ <span class="token function">git</span> reflog 
1a410ef HEAD@<span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">}</span>: reset: moving to 1a410ef 
ab1afef HEAD@<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span>: commit: modified repo.rb a bit 
484a592 HEAD@<span class="token punctuation">{</span><span class="token number">2</span><span class="token punctuation">}</span>: commit: added repo.rb
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p><code>git reflog</code>并不能显示足够多的信息。为了使显示的信息更加有用，我们可以执行<code>git log -g</code>，这个命令会以标准日志的格式输出引用日志</p><h3 id="恢复" tabindex="-1"><a class="header-anchor" href="#恢复" aria-hidden="true">#</a> 恢复</h3><p>看起来下面的那个就是你丢失的提交，你可以通过创建一个新的分支指向这个提交来恢复它。例如 ，你可以创建一个名为<code>recover-branch</code>的分支指向这个提交（ab1afef）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch recover-branch ab1afef
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>现在有一个名为 recover-branch 的分支是你的 master 分支曾经指向的地方，再一次使得前两次提交可到达了</p><h2 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h2><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token comment"># 撤回修改</span>
<span class="token function">git</span> checkout -- <span class="token function">file</span>
<span class="token comment"># 撤回暂存</span>
<span class="token function">git</span> reset <span class="token function">file</span>  <span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">&gt;</span>  <span class="token function">git</span> reset <span class="token parameter variable">--mixed</span> HEAD <span class="token function">file</span>
<span class="token comment"># 撤回提交</span>
<span class="token function">git</span> commit <span class="token parameter variable">--amend</span>

<span class="token comment"># 移动HEAD</span>
<span class="token function">git</span> reset <span class="token parameter variable">--soft</span> commithash
<span class="token comment"># 更新暂存区</span>
<span class="token function">git</span> reset <span class="token parameter variable">--mixed</span> commithash  <span class="token operator">&lt;=</span><span class="token operator">=</span><span class="token operator">&gt;</span>  <span class="token function">git</span> reset commithash
<span class="token comment"># 更新工作区</span>
<span class="token function">git</span> reset <span class="token parameter variable">--hard</span> commithash

<span class="token comment"># 引用日志</span>
<span class="token function">git</span> reflog
<span class="token comment"># 引用日志（详细）</span>
<span class="token function">git</span> log <span class="token parameter variable">-g</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div>`,70),t=[c];function d(r,o){return a(),s("div",null,t)}const p=e(n,[["render",d],["__file","70-17078313777533.html.vue"]]);export{p as default};
