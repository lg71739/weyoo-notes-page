import{_ as a,o as e,c as i,f as s}from"./app-19e0b0f0.js";const t={},n=s(`<h1 id="git分支操作" tabindex="-1"><a class="header-anchor" href="#git分支操作" aria-hidden="true">#</a> Git分支操作</h1><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_17_53_202402132217180.png" alt="image-20210917213616760" tabindex="0" loading="lazy"><figcaption>image-20210917213616760</figcaption></figure><h2 id="什么是分支" tabindex="-1"><a class="header-anchor" href="#什么是分支" aria-hidden="true">#</a> 什么是分支</h2><p>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支。使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行。对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本（分支底层其实也是指针的引用）</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_18_3_202402132218620.png" alt="image-20210917213935209" tabindex="0" loading="lazy"><figcaption>image-20210917213935209</figcaption></figure><h2 id="分支的好处" tabindex="-1"><a class="header-anchor" href="#分支的好处" aria-hidden="true">#</a> 分支的好处</h2><p>同时并行推进多个功能开发，<strong>提高开发效率</strong></p><p>各个分支在开发过程中，如果某一个分支开发失败，<strong>不会对其他分支有任何影响</strong>。失败的分支删除重新开始即可</p><h2 id="分支的操作" tabindex="-1"><a class="header-anchor" href="#分支的操作" aria-hidden="true">#</a> 分支的操作</h2><table><thead><tr><th style="text-align:left;">命令</th><th style="text-align:left;">作用</th></tr></thead><tbody><tr><td style="text-align:left;"><code>git branch 分支名</code></td><td style="text-align:left;">创建分支</td></tr><tr><td style="text-align:left;"><code>git branch -v</code></td><td style="text-align:left;">查看分支</td></tr><tr><td style="text-align:left;"><code>git checkout</code> 分支名</td><td style="text-align:left;">切换分支</td></tr><tr><td style="text-align:left;"><code>git merge</code> 分支名</td><td style="text-align:left;">把指定的分支合并到当前分支</td></tr></tbody></table><h3 id="创建分支、查看分支" tabindex="-1"><a class="header-anchor" href="#创建分支、查看分支" aria-hidden="true">#</a> 创建分支、查看分支</h3><p>1）基本语法</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch 分支名
<span class="token function">git</span> branch <span class="token parameter variable">-v</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>2）案例实操</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_18_43_202402132218042.png" alt="image-20210917214653546" tabindex="0" loading="lazy"><figcaption>image-20210917214653546</figcaption></figure><h3 id="切换分支" tabindex="-1"><a class="header-anchor" href="#切换分支" aria-hidden="true">#</a> 切换分支</h3><p>1）基本语法</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout 分支名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2）案例实操</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_18_51_202402132218909.png" alt="image-20210917215246415" tabindex="0" loading="lazy"><figcaption>image-20210917215246415</figcaption></figure><h3 id="合并分支" tabindex="-1"><a class="header-anchor" href="#合并分支" aria-hidden="true">#</a> 合并分支</h3><p>1）基本语法</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> merge 分支名
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>2）案例实操</p><h4 id="正常合并" tabindex="-1"><a class="header-anchor" href="#正常合并" aria-hidden="true">#</a> <strong>正常合并</strong></h4><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_18_59_202402132218112.png" alt="image-20210917215908842" tabindex="0" loading="lazy"><figcaption>image-20210917215908842</figcaption></figure><h4 id="冲突合并" tabindex="-1"><a class="header-anchor" href="#冲突合并" aria-hidden="true">#</a> <strong>冲突合并</strong></h4><p>冲突产生的原因：合并分支时，两个分支在同一个文件的同一个位置有两套完全不同的修改。Git无法替我们决定使用哪一个。必须人为决定新代码内容</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_19_6_202402132219368.png" alt="image-20210917220923478" tabindex="0" loading="lazy"><figcaption>image-20210917220923478</figcaption></figure><p>解决冲突</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_19_17_202402132219280.png" alt="image-20210917221121233" tabindex="0" loading="lazy"><figcaption>image-20210917221121233</figcaption></figure><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_19_47_202402132219815.png" alt="image-20210917221239011" tabindex="0" loading="lazy"><figcaption>image-20210917221239011</figcaption></figure><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_19_57_202402132219909.png" alt="image-20210917222018377" tabindex="0" loading="lazy"><figcaption>image-20210917222018377</figcaption></figure><div class="hint-container warning"><p class="hint-container-title">提示</p><p>新版本git中新增了merge默认选项<code>strategy=&quot;ort&quot;</code>，对于相同文件的不同行的修改已经可以实现自动合并了。</p><p>只有在相同行都做了修改时，才会出现合并冲突。</p></div><h2 id="实际案例" tabindex="-1"><a class="header-anchor" href="#实际案例" aria-hidden="true">#</a> 实际案例</h2><h3 id="工作流程说明" tabindex="-1"><a class="header-anchor" href="#工作流程说明" aria-hidden="true">#</a> 工作流程说明</h3><ol><li>开发某个网站。</li><li>为实现某个新的需求，创建一个分支。</li><li>在这个分支上开展工作。</li></ol><p>正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：</p><ol><li>切换到你的线上分支（production branch）。</li><li>为这个紧急任务新建一个分支，并在其中修复它。</li><li>在测试通过之后，切换回线上分支，然后合并这个修补分支，最后将改动推送到线上分支。</li><li>切换回你最初工作的分支上，继续工作。</li></ol><h3 id="git-流" tabindex="-1"><a class="header-anchor" href="#git-流" aria-hidden="true">#</a> <strong>Git 流</strong></h3><p>首先，我们假设你正在你的项目上工作，并且已经有一些提交</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_0_42_202402141000243.png" alt="image-20210925201215175" tabindex="0" loading="lazy"><figcaption>image-20210925201215175</figcaption></figure><p>现在，你已经决定要解决你的公司使用的问题追踪系统中的 #53 问题。想要新建一个分支并同时切换到那个分支上</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> iss53
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_0_49_202402141000978.png" alt="image-20210925201355978" tabindex="0" loading="lazy"><figcaption>image-20210925201355978</figcaption></figure><p>你继续在 #53 问题上工作，并且做了一些提交。 在此过程中，iss53 分支在不断的向前推进，因为你已经检出到该分支</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_0_55_202402141000953.png" alt="image-20210925201508485" tabindex="0" loading="lazy"><figcaption>image-20210925201508485</figcaption></figure><p><mark>！！！现在你接到那个电话，有个紧急问题等待你来解决</mark></p><p>有了 Git 的帮助，你不必把这个紧急问题和 iss53 的修改混在一起，你也不需要花大力气来还原关于 #53 问题的修改，然后再添加关于这个紧急问题的修改，最后将这个修改提交到线上分支。你所要做的仅仅是切换回 master 分支</p><p>但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。 最好的方法是，在你切换分支之前，保持好一个干净的状态。（提交你的所有修改）</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout master
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。 请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样</p><p>！！！接下来，你要修复这个紧急问题。让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout <span class="token parameter variable">-b</span> hotfix
<span class="token comment"># 做出修改...</span>
<span class="token function">git</span> commit <span class="token parameter variable">-a</span> <span class="token parameter variable">-m</span> <span class="token string">&#39;fixed the broken email address&#39;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_1_2_202402141001664.png" alt="image-20210925201837035" tabindex="0" loading="lazy"><figcaption>image-20210925201837035</figcaption></figure><p>！！！你可以运行你的测试，确保你的修改是正确的，然后将其合并回你的 master 分支来部署到线上。你可以使用<code>git merge</code>命令来达到上述目的</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout master
<span class="token function">git</span> merge hotfix
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="快进合并" tabindex="-1"><a class="header-anchor" href="#快进合并" aria-hidden="true">#</a> 快进合并</h3><p>在合并的时候，有时候会出现&quot;快进（fast-forward）&quot;这个词</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_1_8_202402141001349.png" alt="image-20210926203522804" tabindex="0" loading="lazy"><figcaption>image-20210926203522804</figcaption></figure><p>由于当前 master 分支所指向的提交是你当前提交的直接上游，所以 Git 只是简单的将指针向前移动。 换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 <mark>“快进合并”</mark></p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_3_1_202402141003314.png" alt="image-20210925202138009" tabindex="0" loading="lazy"><figcaption>image-20210925202138009</figcaption></figure><p>！！！关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。 然而，你应该先删除 hotfix 分支，因为你已经不再需要它了—— master 分支已经指向了同一个位置。 你可以使用带<code>-d</code>选项的<code>git branch</code>命令来删除分支。现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch <span class="token parameter variable">-d</span> hotfix
<span class="token function">git</span> checkout iss53
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_3_2_202402141003453.png" alt="image-20210925202447920" tabindex="0" loading="lazy"><figcaption>image-20210925202447920</figcaption></figure><p>你在 hotfix 分支上所做的工作并没有包含到 iss53 分支中。 如果你需要拉取 hotfix 所做的修改 ，你可以使用<code>git merge master</code>命令将master 分支合并入 iss53 分支，或者你也可以等到 iss53 分支完成其使命，再将其合并回 master 分支</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> checkout master
<span class="token function">git</span> merge iss53
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="典型合并" tabindex="-1"><a class="header-anchor" href="#典型合并" aria-hidden="true">#</a> 典型合并</h3><p>当前的合并和你之前合并 hotfix 分支的时候看起来有一点不一样。在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。因为，master 分支所在提交并不是 iss53 分支所在提交的直接祖先，Git 不得不做一些额外的工作。出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_1_28_202402141001967.png" alt="image-20210926205644299" tabindex="0" loading="lazy"><figcaption>image-20210926205644299</figcaption></figure><p>和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。这个被称作一次 <mark>合并提交</mark>，它的特别之处在于他有不止一个父提交</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_1_36_202402141001760.png" alt="image-20210926205805841" tabindex="0" loading="lazy"><figcaption>image-20210926205805841</figcaption></figure><p>需要指出的是，Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础；这和更加古老的 CVS 系统或者 Subversion（1.5 版本之前）不同，在这些古老的版本管理系统中，用户需要自己选择最佳的合并基础。Git 的这个优势使其在合并操作上比其他系统要简单很多</p><p>最终删除 iss53 号分支</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token function">git</span> branch <span class="token parameter variable">-d</span> iss53
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h3 id="冲突" tabindex="-1"><a class="header-anchor" href="#冲突" aria-hidden="true">#</a> 冲突</h3><p>有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。如果你对 #53 问题的修改和有关 hotfix 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突</p><p>此时 Git 做了合并，但是没有自动地创建一个新的合并提交。Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用<code>git status</code>命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件</p><p>任何因包含合并冲突而有待解决的文件，都会以<strong>未合并状态</strong>标识出来</p><div class="language-bash line-numbers-mode" data-ext="sh"><pre class="language-bash"><code><span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;&lt;&lt;</span><span class="token operator">&lt;</span> HEAD:index.html 
<span class="token operator">&lt;</span>div <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">&quot;footer&quot;</span><span class="token operator">&gt;</span>contact <span class="token builtin class-name">:</span> email.support@github.com<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span> 
<span class="token operator">==</span><span class="token operator">==</span><span class="token operator">==</span><span class="token operator">=</span> 
<span class="token operator">&lt;</span>div <span class="token assign-left variable">id</span><span class="token operator">=</span><span class="token string">&quot;footer&quot;</span><span class="token operator">&gt;</span> 
  please contact us at support@github.com 
<span class="token operator">&lt;</span>/div<span class="token operator">&gt;</span> 
<span class="token operator">&gt;&gt;</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;&gt;</span><span class="token operator">&gt;</span> iss53:index.html 
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>在你解决了所有文件里的冲突之后，对每个文件使用<code>git add</code>命令来将其标记为冲突已解决。 一旦暂存这些原本有冲突的文件，Git 就会将它们标记为<strong>冲突已解决</strong></p><h2 id="分支的知识拓展" tabindex="-1"><a class="header-anchor" href="#分支的知识拓展" aria-hidden="true">#</a> 分支的知识拓展</h2><h3 id="创建分支和切换分支图解" tabindex="-1"><a class="header-anchor" href="#创建分支和切换分支图解" aria-hidden="true">#</a> 创建分支和切换分支图解</h3><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_20_6_202402132220214.png" alt="image-20210917221451896" tabindex="0" loading="lazy"><figcaption>image-20210917221451896</figcaption></figure><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/13_22_20_15_202402132220033.png" alt="image-20210917221515718" tabindex="0" loading="lazy"><figcaption>image-20210917221515718</figcaption></figure><p>master、hot-fix 其实都是指向具体版本记录的指针。</p><p>当前所在的分支，其实是由 HEAD 决定的。所以创建分支的本质就是多创建一个指针</p><ul><li>HEAD 如果指向 master，那么我们现在就在 master 分支上</li><li>HEAD 如果指向 hotfix，那么我们现在就在 hotfix 分支上</li></ul><p>所以切换分支的本质就是移动HEAD指针</p><h3 id="分支模式" tabindex="-1"><a class="header-anchor" href="#分支模式" aria-hidden="true">#</a> 分支模式</h3><h4 id="长期分支-master" tabindex="-1"><a class="header-anchor" href="#长期分支-master" aria-hidden="true">#</a> 长期分支（master）</h4><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_6_13_202402141006792.png" alt="image-20210926210424127" tabindex="0" loading="lazy"><figcaption>image-20210926210424127</figcaption></figure><p>许多使用 Git 的开发者都喜欢使用这种方式来工作，比如只在 master 分支上保留完全稳定的代码——有可能仅仅是已经发布或即将发布的代码。他们还有一些名为 develop 或者 next 的平行分支，被用来做后续开发或者测试稳定性——这些分支不必保持绝对稳定，但是一旦达到稳定状态，它们就可以被合并入 master 分支了，等待下一次的发布。随着你的提交而不断右移的指针。稳定分支的指针总是在提交历史中落后一大截，而前沿分支的指针往往比较靠前</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_6_24_202402141006411.png" alt="image-20210926210544548" tabindex="0" loading="lazy"><figcaption>image-20210926210544548</figcaption></figure><h4 id="特性分支-topic" tabindex="-1"><a class="header-anchor" href="#特性分支-topic" aria-hidden="true">#</a> 特性分支（topic）</h4><p>特性分支对任何规模的项目都适用。特性分支是一种<mark>短期分支</mark>，它被用来实现单一特性或其相关工作。也许你从来没有在其他的版本控制系统（VCS）上这么做过，因为在那些版本控制系统中创建和合并分支通常很费劲。然而，在 Git 中一天之内多次创建、使用、合并、删除分支都很常见</p><h3 id="分支本质" tabindex="-1"><a class="header-anchor" href="#分支本质" aria-hidden="true">#</a> 分支本质</h3><p><mark>Git 分支，其实本质上仅仅是指向提交对象的可变指针</mark>。Git 的默认分支名字是 master。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 master 分支。它会在每次的提交操作中自动向前移动</p><p><strong>注意：</strong> Git 的 “master” 分支并不是一个特殊分支。它就跟其它分支完全没有区别。之所以几乎每一个仓库都有 master 分支，是因为<code>git init</code>命令默认创建它，并且大多数人都懒得去改动它</p><figure><img src="https://jihulab.com/byzh123/images/-/raw/images/pictures/2024/02/14_10_6_29_202402141006756.png" alt="image-20210926211420948" tabindex="0" loading="lazy"><figcaption>image-20210926211420948</figcaption></figure><h3 id="分支原理" tabindex="-1"><a class="header-anchor" href="#分支原理" aria-hidden="true">#</a> 分支原理</h3><h4 id="git-refs-目录" tabindex="-1"><a class="header-anchor" href="#git-refs-目录" aria-hidden="true">#</a> .git/refs 目录</h4><p>这个目录中保存了分支及其对应的提交对象</p><h4 id="head-引用" tabindex="-1"><a class="header-anchor" href="#head-引用" aria-hidden="true">#</a> HEAD 引用</h4><p>当运行类似于<code>git branch (branchname)</code>这样的命令时，Git 会取得当前所在分支最新提交对应的 SHA-1 值，并将其加入你想要创建的任何新分支中。当你执行<code>git branch (branchname)</code>时，Git 如何知道最新提交的 SHA-1 值呢？答案是 HEAD 文件。HEAD 文件是一个符号引用（symbolic reference），指向目前所在的分支。所谓符号引用，意味着它并不像普通引用那样包含一个 SHA-1 值。它是一个指向其他引用的指针</p>`,105),r=[n];function d(c,l){return e(),i("div",null,r)}const o=a(t,[["render",d],["__file","30-1707831377322.html.vue"]]);export{o as default};
